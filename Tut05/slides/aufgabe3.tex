\begin{frame}[fragile]
    \begin{exercise}
        Betrachten Sie eine zweistellige Funktion \T{power}, die für natürliche Zahlen $b$ und $e$ den Wert $b^e$ berechnet.
    \end{exercise}
    \begin{solve}[a) Geben Sie \T{power} als mathematische Funktion an]
        $$power:\mathbb{N}\times\mathbb{N}\to\mathbb{N},\;(b,e)\mapsto b^e$$
    \end{solve}
\end{frame}
% copy to cleanup my code
\addtocounter{exercise}{-1}\addtocounter{solve}{-1}% reset counters
\begin{frame}[fragile]
    \begin{exercise}
        Betrachten Sie eine zweistellige Funktion \T{power}, die für natürliche Zahlen $b$ und $e$ den Wert $b^e$ berechnet.
    \end{exercise}
    \begin{solve}[b) Programmieren Sie \T{power} in haskell]
    \begin{plainhaskell}
power :: Integer -> Integer -> Integer
power b e =
    if e >= 0 && b >= 0
    then b ^ e
    else -1
    \end{plainhaskell}
    \begin{itemize}
        \item Wegen \textit{Currying} gibt es nur einstellige Funktionen: $\mathbb{D}=\T{Integer}$.
        \item Zielmenge: Funktion $\mathbb{W}=\T{\{Integer -> Integer\}}$
    \end{itemize}
    \end{solve}
\end{frame}
% copy to cleanup my code
\addtocounter{exercise}{-1}\addtocounter{solve}{-1}% reset counters
\begin{frame}[fragile]
    \begin{exercise}
        Programmieren Sie die einstellige Funktion \T{powerOfTwo}, die für eine natürliche Zahl $e$ den Wert $2^e$ berechnet.
    \end{exercise}
    \begin{solve}[c)]
    \begin{plainhaskell}
-- mit Parameter
powerOfTwoA :: Integer -> Integer
powerOfTwoA e = power 2 e

-- wir nutzen Currying
powerOfTwoB :: Integer -> Integer
powerOfTwoB = power 2
    \end{plainhaskell}
    \end{solve}
\end{frame}